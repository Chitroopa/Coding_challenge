#---------------------------------------------------------------------------------------------
# python cheat sheet
#----------------------------------------------------------------------------------------------

> create m * n matrix  
    matrix = [[0]*n for _ in range(m)]
    
> access last element in matrix
    matrix[-1][-1]
    
> move vertically and horizontally in 2d matrix
    [(-1,0),(1,0),(0,-1),(0,1)] #[up, down, left, right]
    
> move diagonally in 2d matrix
    [(-1,-1),(1,1),(-1,1),(1,-1)]
    
> sort in decending order 
    listname.sort(reverse = True)
    
> heap
    #heapq defult is min heap
    import heapq
    heap = []
    heapify(heap) # transforms list X into heap 
    heappush(heap, item)
    heappop(heap) 
    heap[0] # lookup smallest element 
    heappushpop(heap, item)
    
    # max heap hack
    heappush(heap, -item) # change item value to negative
    
> defult dictonary
    from collections import defaultdict
    new_map = defaultdict(list) # default value is list => { key:[]}
    new_map = defaultdict(int) # default value as integer
    new_map = defaultdict(set) # default value as set 

> counter 
    from collections import Counter
    a = [1,1,1,1,1,1,2,2,3,3]
    new_map = dict(Counter(a))

> itertools 
    # eg: to get boundary coordinates for board
    
    from itertools import chain, repeat
    boundary = set(chain(zip(repeat(0), range(cols)), #top 
                        zip(repeat(rows-1), range(cols)), #bottom
                        zip(range(rows),repeat(0)), #left
                        zip(range(rows), repeat(cols-1)))) #right 
   # repeat(10, 3) --> 10 10 10 #A common use for repeat is to supply a stream of constant values to imap or zip
   # chain('ABC', 'DEF') --> A B C D E F
   # zip((1,2,3),(4,5,6)) ---> (1, 4), (2, 5), (3, 6) Iterator objects that will be joined together   


#----------------------------------------------------------------------------------------------
# find all substrings
#----------------------------------------------------------------------------------------------
def findsubstring(string):
    result = []
    counter = 1
    while counter < len(string):
        for i in range(len(string)):
            slice_s = string[i: i+counter]
            if len(slice_s) == counter:
                result.append(slice_s)
        counter += 1
    return result

print(findsubstring('chitroopa'))
#------------------------------------------<<<<< End >>>> ---------------------------------------


#-------------------------------------------------------------------------------------------------
# Backtracking 
#------------------------------------------------------------------------------------------------
eg: perumtation # A “combination lock” should really be called a “permutation lock”. The order you put in the numbers of lock matters
def permutation(chars, strSoFar):
  if not chars: return print(strSoFar)
  for c in chars:
    currChar = c
    chars.remove(c)
    permutation(chars, strSoFar + currChar)
    chars.add(c)

chars = {'a', 'b', 'c', 'd'}
strSoFar = ""
permutation(chars, strSoFar)

----------------------------------------<<End>>---------------------------------------------------------
