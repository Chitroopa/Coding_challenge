#---------------------------------------------------------------------------------------------
# python cheat sheet
#----------------------------------------------------------------------------------------------

> create m * n matrix  
    matrix = [[0]*n for _ in range(m)]
    
> access last element in matrix
    matrix[-1][-1]
    
> move vertically and horizontally in 2d matrix
    [(-1,0),(1,0),(0,-1),(0,1)] #[up, down, left, right]
    
> move diagonally in 2d matrix
    [(-1,-1),(1,1),(-1,1),(1,-1)]
    
> sort in decending order 
    listname.sort(reverse = True)

> Infinity 
    a = float('inf') # postive infinity 
    a = float('-inf') # negative infinity
    
> integer range from -2147483648 to 2147483647

> to get the place value (ones tens hundreds)
    n = "123"
    res = 0
    for i in range(len(n))
        v = int(n) * 10**(len(n)-1-i)) # 3 * 10**(3-1-1) => 3*10**0 =>3*1 =>3
        res += v
    # ** - 'power of' eg 10**2 -> 10 time 2
    
> exception handler
    try: 
        res_int = int(res_str)
        if -2147483648 < res_int < 2147483647:
            return res_int
        else: return -2147483648 if sign == '-' else 2147483647
    except:
        return 0


> str.Zfill(width)
    x = "1"
    x.zfill(2) # x = "01"
    
    #The zfill() method pads string on the left with zeros to fill width.
    
> sort a string
    s = "bqwxa"
    print(sorted(s)) # ['a', 'b', 'q', 'w', 'x']
    temp = "".join(sorted(s)) # temp = abqwx


> nonlocal variable #used in nested loops
    nonlocal variable_name

> looping 
    a = [1,2,3,4]
    print([x for x in range(len(a)-1, -1, -1) ]) # reverse loop [3, 2, 1, 0]
    print([x for x in range(len(a))]) # [0, 1, 2, 3]
    
    # range([start], stop[, step])    
        
> heap
    #heapq defult is min heap
    import heapq
    heap = []
    heapify(heap) # transforms list X into heap 
    heappush(heap, item)
    heappop(heap) 
    heap[0] # lookup smallest element 
    heappushpop(heap, item)
    
    # max heap hack
    heappush(heap, -item) # change item value to negative
    
> defult dictonary
    from collections import defaultdict
    new_map = defaultdict(list) # default value is list => { key:[]}
    new_map = defaultdict(int) # default value as integer
    new_map = defaultdict(set) # default value as set 

> counter 
    from collections import Counter
    a = [1,1,1,1,1,1,2,2,3,3]
    new_map = Counter(a)
    
> OrderedDict() - remembers the order of insertion - used in LRU Cache implementation
    from collections import OrderedDict
    new_OD = OrderedDict()
    new_OD['a'] = 2
    new_OD['b'] = 3
    new_OD['c'] = 4
    print(new_OD)           # prints OrderedDict([('a', 2), ('b', 3), ('c', 4)])

    new_OD.move_to_end('a') # moves element to right end(default)
    print(new_OD)           # prints OrderedDict([('b', 3), ('c', 4), ('a', 2)])

    new_OD.move_to_end('b', last=False) # moves element to Left end
    print(new_OD)                       # prints OrderedDict([('b', 3), ('c', 4), ('a', 2)])

    new_OD.popitem(last= True)  # LIFO
    print(new_OD)               # prints OrderedDict([('b', 3), ('c', 4)])

    new_OD.popitem(last= False) # FIFO
    print(new_OD)               #prints OrderedDict([('c', 4)])
        
    

> itertools 
    # eg: to get boundary coordinates for board
    
    from itertools import chain, repeat
    boundary = set(chain(zip(repeat(0), range(cols)), #top 
                        zip(repeat(rows-1), range(cols)), #bottom
                        zip(range(rows),repeat(0)), #left
                        zip(range(rows), repeat(cols-1)))) #right 
   # repeat(10, 3) --> 10 10 10 #A common use for repeat is to supply a stream of constant values to imap or zip
   # chain('ABC', 'DEF') --> A B C D E F
   # zip((1,2,3),(4,5,6)) ---> (1, 4), (2, 5), (3, 6) Iterator objects that will be joined together   

#---------------------------------------------<<End>>-------------------------------------------

#----------------------------------------------------------------------------------------------
# DS and Algorithm cheat sheet
#----------------------------------------------------------------------------------------------

> using collections (hashMap, hashSet, Stack and queue)
    - find a pair/group of numbers satisfying a given target condition. eg: find two numbers in a array that sums up to the given target number.

> Sorting:
    - Rearrange the given array elements in a specified way to obtain the output

> Simple array traversal:
    - Find a single value or a transformation of the given array in some way.

> Two pointers:
    - search set of elements with a given condition. Eg: container with most water
    - find triplets or a sub array with the given condition
> Fast and slow pointers:
    - find the position of an element, or the length of the array, where the array hass cycle/loop.
> Two heaps:
    - find the smallest/largest/medium element of an array
> Subsets:
    - permuntation and combination of a given set
> Top K elements:
    - find the top k smallest/largest/frequent elements of an array
> sliding window:
    -find the short/long subset of a given array
> Merge Intervals:
    - find overlapping intervals/mutually exclusive intervals/ merge intervals given the input is a list/array of intervals [t1.t2]
> Backtracking:
    - find permuntaions or combinations of the array elements
    
> DP:
    - memoization
    - tabulation 






#----------------------------------------------------------------------------------------------
# find all substrings
#----------------------------------------------------------------------------------------------
def findsubstring(string):
    result = []
    counter = 1
    while counter < len(string):
        for i in range(len(string)):
            slice_s = string[i: i+counter]
            if len(slice_s) == counter:
                result.append(slice_s)
        counter += 1
    return result

print(findsubstring('chitroopa'))
#------------------------------------------<<<<< End >>>> ---------------------------------------


#-------------------------------------------------------------------------------------------------
# Backtracking 
#------------------------------------------------------------------------------------------------
eg: perumtation # A “combination lock” should really be called a “permutation lock”. The order you put in the numbers of lock matters
def permutation(chars, strSoFar):
  if not chars: return print(strSoFar)
  for c in chars:
    currChar = c
    chars.remove(c)
    permutation(chars, strSoFar + currChar)
    chars.add(c)

chars = {'a', 'b', 'c', 'd'}
strSoFar = ""
permutation(chars, strSoFar)

----------------------------------------<<End>>---------------------------------------------------------
